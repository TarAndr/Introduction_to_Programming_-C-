/******************************************************************************

Дано число N. Определите, сколькими способами можно расставить на доске N×N N ферзей, не бьющих друг друга.

Формат входных данных
Задано единственное число N. (N ≤ 10)

Формат выходных данных
Выведите ответ на задачу.
Подсказка
Напишите рекурсивную функцию, которая пытается поставить ферзя в очередной столбец. Если на эту клетку ставить ферзя нельзя (он бьет предыдущих), то такой вариант даже не стоит рассматривать. Когда вы успешно поставили ферзя в последний столбец - увеличивайте счетчик.
Sample Input:

8
Sample Output:

92

*******************************************************************************/

#include <iostream>

using namespace std;

// Функция перебора возможных положений ферзя
int queen(int n, int row, int I[], int J[]) {
    // Если достигнут конец поля
    if(row >= n) {
        return 1;
    }
    int cnt = 0;    // Счётчик успешных расстановок
    for(int i = 0; i < n; i++) {
        bool hit = 0;    // Флаг неудачной попытки
        for(int j = 0; j < row; j++) {
            // Проверка клетки на доступность:
            if(row == I[j] || i == J[j]
                || (row - I[j]) == (i - J[j]) 
                || (row - I[j]) == (J[j] - i)) {
                hit = 1;
                break;
            }
        }
        if(hit) {
            continue;
        }
        I[row] = row;
        J[row] = i;
        cnt += queen(n, row + 1, I, J);
    }
    return cnt;
}

int number_of_ways(int n) {
    if(n < 1) {
        return 0;
    }
    int I[n - 1], J[n - 1];
    return queen(n, 0, I, J);
}

int main()
{
    int a;
    
    cin >> a;
    
    cout << number_of_ways(a) << endl;
    
    return 0;
}
